---
title: Изучаем матрицы трансформаций в CSS
authors:
- tiffany-brown
tags:
- css
- coordinates
- transform
- matrices
- matrix
- transform-origin
- vector
- math
license: cc-by-3.0
layout: article
---

## Введение

Матричные функции — `matrix()` and `matrix3d()` — две самые головоломные в плане понимания вещи в [CSS3-трансформациях][6]. В большинстве случаев, ради простоты и ясности, вы будете пользоваться функциями вроде `rotate()` и `skewY()`. Но всё же за каждой трансформацией скрывается эквивалентная матрица. Полезно хоть слегка понимать, как они работают, так что давайте рассмотрим их поближе.

[6]: http://dev.w3.org/csswg/css3-transforms/

CSS-трансформации «растут» из линейной алгебры и геометрии. Хотя продвинутая математическая подготовка будет весьма не лишней, понять матричные функции можно и без нее. Но вы должны быть хорошо знакомы с CSS-трансформациями. Если нет, то почитайте статью «[CSS3 transitions and 2D transforms][7]».

[7]: http://dev.opera.com/articles/css3-transitions-and-2D-transforms/

В этой статье я охвачу как матрицы 3×3, используемые для двумерных трансформаций, так и матрицы 4×4 для трехмерных.

Заметьте, что на момент этой публикации Opera не поддерживает трехмерных трансформаций. Я включила двумерный `matrix()`-эквивалент, где возможно.

В этой статье я также пользуюсь беспрефиксными версиями свойств `transform`. На практике эти свойства всё еще экспериментальны и могут измениться. Пока они не утверждены окончательно, добавляйте в свой CSS-код версии с префиксом (напр., `-o-transform`).

## Что такое матрица?

[Матрица][8] — это прикольный математический термин для прямоугольного массива чисел, символов или выражений (см. [рис. 1](#figure-1)). У матриц множество математических и научных применений. Физики, например, используют их при изучении квантовой механики. В области компьютерной графики они используются для вещей типа — внезапно! — линейных трансформаций и проекции трехмерных изображений на двумерный экран. Это и есть то, что делают матричные функции: `matrix()` позволяет нам создавать линейные трансформации, а `matrix3d()` дает возможность создавать иллюзию трехмерности в двух измерениях с помощью CSS.

[8]: http://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0_%28%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0%29

<figure id="figure-1">
	<img src="/articles/understanding-the-css-transforms-matrix/1.gif" alt="Сетка с цифрами 3×3: верхний ряд 1, 2, 8; средний ряд: 10, 3, 9; нижний ряд: 7, 4, 0">
	<figcaption markdown="span">Рис. 1. Пример матрицы</figcaption>
</figure>

Мы не будем далеко забредать в глубины продвинутой алгебры. Вы должны быть знакомы с [декартовой системой координат][11]. Можете также освежить в памяти, [как перемножать матрицы и векторы][12] (либо воспользуйтесь [калькулятором][13], типа предлагаемого Bluebit.gr).

[11]: http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D1%8F%D0%BC%D0%BE%D1%83%D0%B3%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D0%BA%D0%BE%D0%BE%D1%80%D0%B4%D0%B8%D0%BD%D0%B0%D1%82
[12]: http://ru.wikipedia.org/wiki/%D0%A3%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86
[13]: http://www.bluebit.gr/matrix-calculator/

Важный для понимания момент — то, что трансформация умножает матрицу на координаты точки (или точек), выраженные в виде вектора.

## Трансформации и системы координат

Сначала поговорим о системах координат. Каждая область просмотра документа является системой координат. Левый верхний угол — ее начало, с координатами `(0,0)`. Значения увеличиваются вправо по оси _X_ и вниз по оси _Y_. Ось _Z_ определяет кажущееся расстояние до зрителя в случае 3D-трансформаций. Бо́льшие значения — предметы ближе и крупнее, меньшие значения — мельче и дальше.

Когда трансформация применяется к объекту, она создает локальную систему координат. По умолчанию начало локальных координат — точка `(0,0)` — лежит в центре объекта, или на 50% ширины и 50% высоты ([рис. 2](#figure-2)).

<figure id="figure-2">
	<img src="/articles/understanding-the-css-transforms-matrix/2.gif" alt="Пример локальной системы координат">
	<figcaption markdown="span">Рис.2. Локальная система координат</figcaption>
</figure>

Мы можем изменить начало локальной системы координат подгонкой свойства `transform-origin` ([рис. 3](#figure-3)). Задание `transform-origin: 50px 70px;`, например, помещает начало координат в 50 пикселях от левого края объекта и в 70 пикселях от его верха. Трансформации каждой точки в локальной системе координат объекта рассчитываются относительно этого начала.

<figure id="figure-3">
	<img src="/articles/understanding-the-css-transforms-matrix/4.gif" alt="Пример локальной системы координат">
	<figcaption markdown="span">Рис. 3. Локальная система координат, с началом в точке `(50px,70px)`. Также показана точка `(30px,30px)`</figcaption>
</figure>

Браузеры делают за вас эти вычисления каждый раз, когда вы применяете трансформацию. Вам нужно лишь знать, какие аргументы могут помочь достичь нужного вам эффекта.

## Расчет трансформации: математика матриц и векторов

Взглянем на пример с использованием [матрицы 3×3][18] для расчета двумерной трансформации ([рис. 4](#figure-4)). [Матрица 4×4][20], используемая для трехмерных трансформаций, работает так же, с дополнительными числами для добавочной оси _Z_.

[18]: http://www.w3.org/TR/SVG/coords.html#TransformMatrixDefined
[20]: http://www.w3.org/TR/css3-transforms/#mathematical-description

<figure id="figure-4">
	<img src="/articles/understanding-the-css-transforms-matrix/3.gif" alt="Сетка с цифрами 3×3. Верхний ряд: a, c, e; средний ряд: b, d, f; нижний ряд: 0, 0, 1">
	<figcaption markdown="span">Рис. 4. Матрица двумерной CSS-трансформации</figcaption>
</figure>

Мы можем записать это как `transform: matrix(a,b,c,d,e,f)`, где буквы от `a` до `f` — числа, определяемые типом трансформации, которую мы хотим применить. Матрицы — это рецепты тех видов трансформации, которые мы хотим применить. Это станет чуть понятнее, когда мы рассмотрим несколько примеров.

Когда мы применяем двумерную трансформацию, браузер умножает матрицу на вектор `[x, y, 1]`. Значения _X_ и _Y_ — координаты конкретной точки в локальном пространстве координат.

Чтобы найти координаты после трансформации, мы умножаем каждый элемент каждой строки матрицы на соответствующую ему строку вектора. Затем складываем произведения ([рис. 5](#figure-5)).

<figure id="figure-5">
	<img src="/articles/understanding-the-css-transforms-matrix/5.gif" alt="При умножении матрицы на вектор, результат это сумма результатов каждого элемента матрицы, помноженного на соответствующий элемент вектора">
	<figcaption markdown="span">Рис. 5. Умножение матрицы на вектор</figcaption>
</figure>

Я знаю, что это выглядит как куча бессмысленных цифр и букв. Но, как отмечено выше, у каждого типа трансформаций — своя собственная матрица. [Рис. 6](#figure-6) показывает матрицу для трансформации сдвига.

<figure id="figure-6">
	<img src="/articles/understanding-the-css-transforms-matrix/6.gif" alt="Матрица сдвига">
	<figcaption markdown="span">Рис. 6. Матрица сдвига</figcaption>
</figure>

Значения `tx` и `ty` — значения, на которые должно быть сдвинуто начало координат. Мы также можем представить это с помощью вектора `[1 0 0 1 tx ty]`. Этот вектор служит аргументом для функции `matrix()`, как показано ниже.

	#mydiv {
		transform: matrix(1, 0, 0, 1, tx, ty);
		}

Давайте трансформируем объект, левый верхний угол которого совпадает с левым верхним углом области просмотра ([Рис. 7](#figure-7)). Его глобальные координаты равны `(0,0)`.

<figure id="figure-7">
	<img src="/articles/understanding-the-css-transforms-matrix/4b.png" alt="Объект с глобальными координатами (0,0)">
	<figcaption markdown="span">Рис. 7. Объект с глобальными координатами `(0,0)`</figcaption>
</figure>

Мы переместим этот объект на 150 пикселей по осям _X_ и _Y_, используя начало координат трансформации по умолчанию. Ниже приведен CSS для этой трансформации.

	#mydiv {
		transform: matrix(1, 0, 0, 1, 150, 150);
		}

Кстати, это эквивалентно `transform: translate(150px,150px)`. Давайте рассчитаем результат этой трансформации для точки с координатами `(220px,220px)` ([Рис. 8](#figure-8)).

<figure id="figure-8">
	<img src="/articles/understanding-the-css-transforms-matrix/7.gif" alt="Вычисление трансформации сдвига">
	<figcaption markdown="span">Рис. 8. Вычисление трансформации сдвига</figcaption>
</figure>

Трансформации задают соответствие координатам и расстояниям в локальной системе координат объекта предыдущей системе координат. То, где точка отобразится в области просмотра, зависит от примененного при трансформации сдвига от начальной точки объекта. В этом примере наша точка с координатами `(220px,220px)` теперь отображается в точке `(370px,370px)`. Прочие координаты в границах нашего объекта тоже сместились на 150 пикселей вправо и на 150 пикселей вниз ([рис. 9](#figure-9)).

<figure id="figure-9">
	<img src="/articles/understanding-the-css-transforms-matrix/7b.png" alt="Наш объект после применения трансформации">
	<figcaption markdown="span">Рис. 9. Наш объект после применения трансформации</figcaption>
</figure>

Матрица сдвига — особый случай. Она как _аддитивна_, так и _мультипликативна_. Более простым решением было бы просто прибавить значение сдвига к значениям _X- и Y-координат_ нашей точки.

### Расчет трехмерной трансформации

Выше мы рассмотрели матрицу переноса 3×3. Давайте возьмем другой пример, с использованием матрицы 4×4 для масштабирования ([рис. 10](#figure-10)).

<figure id="figure-10">
	<img src="/articles/understanding-the-css-transforms-matrix/8.gif" alt="Матрица 4×4 для масштабирования">
	<figcaption markdown="span">Рис. 10. Матрица 4×4 для масштабирования</figcaption>
</figure>

Здесь _sx_, _sy_ и _sz_ представляют масштабные коэффициенты по каждой оси. С функцией `matrix3d` это примет такой вид: `transform: matrix3d(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1)`.

Будем продолжать с тем же объектом, что раньше. Уменьшим его масштаб по осям _X_ и _Y_ с помощью функции `matrix3d()`, как показано ниже.

	#mydiv{
		transform: matrix3d(.8, 0, 0, 0, 0, .5, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
		}

Это эквивалентно `transform: scale3d(0.8, 0.5, 1)`. Поскольку мы масштабируем только по осям _X_ и _Y_ (получая 2D-трансформацию), мы могли бы использовать также `transform: matrix(.8, 0, 0, .5, 0, 0)` либо `scale(.8,.5)`. Результат трансформации виден на [рис. 11](#figure-11).

<figure id="figure-11">
	<img src="/articles/understanding-the-css-transforms-matrix/9b.png" alt="Объект 300×300 пикселей после применения трансформации масштабирования">
	<figcaption markdown="span">Рис. 11. Объект 300×300 пикселей после применения трансформации масштабирования</figcaption>
</figure>

Если умножить эту матрицу на координатный вектор `[150,150,1]`, ([рис. 12](#figure-12)), мы получим такие новые координаты нашей точки: `(120,75,1)`.

<figure id="figure-12">
	<img src="/articles/understanding-the-css-transforms-matrix/9.gif" alt="Вычисление трансформации масштабирования">
	<figcaption markdown="span">Рис. 12: Вычисление трансформации масштабирования</figcaption>
</figure>

### Где взять значения матриц

Значения матриц для каждой функции трансформации приведены как в спецификации [Scalable Vector Graphics][38], так и в спецификации [CSS Transforms][39].

[38]: http://www.w3.org/TR/SVG/coords.html#TransformMatrixDefined
[39]: http://www.w3.org/TR/css3-transforms/#mathematical-description

## Составные трансформации с помощью матриц

Наконец, давайте рассмотрим, как создать составную трансформацию — трансформацию, эквивалентную применению нескольких функций трансформации одновременно. Ради простоты ограничимся двумя измерениями. Это значит, что мы будем использовать матрицу трансформации 3×3 и функцию matrix(). Этой трансформацией мы повернем наш объект на 45° и увеличим его масштаб в 1,5 раза от исходного размера.

Матрица поворота, выраженная в виде вектора — `[cos(a) sin(a) -sin(a) cos(a) 0 0]`, где _a_ — угол. Для масштабирования понадобится матрица `[sx 0 0 sy 0 0]`. Чтобы объединить их, умножим матрицу поворота на матрицу масштабирования, как показано на [рис. 13](#figure-13) (синус и косинус 45° оба равны 0,7071).

<figure id="figure-13">
	<img src="/articles/understanding-the-css-transforms-matrix/10.gif" alt="Вычисление матрицы составной трансформации">
	<figcaption markdown="span">Рис. 13: Вычисление матрицы составной трансформации</figcaption>
</figure>

В CSS это будет выглядеть так: `transform: matrix(1.0606, 1.0606, -1.0606, 1.0606, 0, 1)`. [Рис. 14](#figure-14) показывает результат после применения трансформации.

<figure id="figure-14">
	<img src="/articles/understanding-the-css-transforms-matrix/10b.png" alt="Наш объект 300×300 пикселей после масштабирования и поворота">
	<figcaption markdown="span">Рис. 14: Наш объект 300×300 пикселей после масштабирования и поворота</figcaption>
</figure>

Теперь рассчитаем новые координаты в области просмотра для точки `(298,110)`, как показано на [рис. 15](#figure-15).

<figure id="figure-15">
	<img src="/articles/understanding-the-css-transforms-matrix/11.gif" alt="Применение трансформации">
	<figcaption markdown="span">Рис. 15. Применение трансформации</figcaption>
</figure>

Новыми координатами нашей точки будут `(199.393px,432.725px)`.

## Узнать больше

Надеюсь, эта статья немного приподняла завесу тайны над CSS-трансформациями. Если ей это не удалось, попробуйте обратиться к ресурсам ниже.

- [Матрица (математика)][46] в Википедии
- [Объяснение матрицы трансформации во Flash 8][47] (автор — Senocular)
- [Трансформации][48] на сайте WolframMathWorld

[46]: http://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0_%28%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0%29
[47]: http://www.senocular.com/flash/tutorials/transformmatrix/
[48]: http://mathworld.wolfram.com/topics/Transformations.html
